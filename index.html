<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     张玉虎
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">张玉虎</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Dubbo三大神器（监听器、拦截器和过滤器）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/21/Dubbo%E4%B8%89%E5%A4%A7%E7%A5%9E%E5%99%A8%EF%BC%88%E7%9B%91%E5%90%AC%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89/"
    >Dubbo三大神器（监听器、拦截器和过滤器）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/21/Dubbo%E4%B8%89%E5%A4%A7%E7%A5%9E%E5%99%A8%EF%BC%88%E7%9B%91%E5%90%AC%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89/" class="article-date">
  <time datetime="2020-06-21T00:35:20.000Z" itemprop="datePublished">2020-06-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dubbo/">Dubbo</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-监听器"><a href="#1-监听器" class="headerlink" title="1 监听器"></a>1 监听器</h1><h1 id="2-拦截器"><a href="#2-拦截器" class="headerlink" title="2 拦截器"></a>2 拦截器</h1><h1 id="3-过滤器"><a href="#3-过滤器" class="headerlink" title="3 过滤器"></a>3 过滤器</h1>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-Spring状态机" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/20/Spring%E7%8A%B6%E6%80%81%E6%9C%BA/"
    >Spring状态机</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/20/Spring%E7%8A%B6%E6%80%81%E6%9C%BA/" class="article-date">
  <time datetime="2020-06-20T09:52:56.000Z" itemprop="datePublished">2020-06-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>Spring状态机的有一下特征：</p>
<ol>
<li>Easy to use flat one level state machine for simple use cases.</li>
</ol>
<blockquote>
<p>易于使用的扁平的一级状态机，用于简单的用例</p>
</blockquote>
<ol start="2">
<li>Hierarchical state machine structure to ease complex state configuration.</li>
</ol>
<blockquote>
<p>分层状态机结构，以简化复杂的状态配置</p>
</blockquote>
<ol start="3">
<li>State machine regions to provide even more complex state configurations.</li>
</ol>
<blockquote>
<p>状态机区域提供更复杂的状态配置</p>
</blockquote>
<ol start="4">
<li>Usage of triggers, transitions, guards and actions.</li>
</ol>
<blockquote>
<p>触发器、转换、保护和操作的使用</p>
</blockquote>
<ol start="5">
<li>Type safe configuration adapter.</li>
</ol>
<blockquote>
<p>类型安全配置适配器</p>
</blockquote>
<ol start="6">
<li>Builder pattern for easy instantiation for use outside of Spring Application context</li>
</ol>
<blockquote>
<p>在Spring应用程序上下文之外使用的易于实例化的构建器模式</p>
</blockquote>
<ol start="7">
<li>Recipes for usual use cases</li>
</ol>
<blockquote>
<p>常用用例的用法</p>
</blockquote>
<ol start="8">
<li>Distributed state machine based on a Zookeeper</li>
</ol>
<blockquote>
<p>基于Zookeeper的分布式状态机</p>
</blockquote>
<ol start="9">
<li>State machine event listeners.</li>
</ol>
<blockquote>
<p>状态机时间监听</p>
</blockquote>
<ol start="10">
<li>UML Eclipse Papyrus modeling.</li>
</ol>
<blockquote>
<p>UML Eclipse文献建模</p>
</blockquote>
<ol start="11">
<li>Store machine config in a persistent storage.</li>
</ol>
<blockquote>
<p>将机器配置存储在永久性存储器中</p>
</blockquote>
<ol start="12">
<li>Spring IOC integration to associate beans with a state machine.</li>
</ol>
<blockquote>
<p>Spring IOC集成，将bean与状态机相关联</p>
</blockquote>
<h1 id="2-简单使用方式"><a href="#2-简单使用方式" class="headerlink" title="2 简单使用方式"></a>2 简单使用方式</h1><h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3 持久化"></a>3 持久化</h1><h1 id="4-状态及事件"><a href="#4-状态及事件" class="headerlink" title="4 状态及事件"></a>4 状态及事件</h1><h1 id="5-流程配置"><a href="#5-流程配置" class="headerlink" title="5 流程配置"></a>5 流程配置</h1><h1 id="6-外部调用-amp-事务"><a href="#6-外部调用-amp-事务" class="headerlink" title="6 外部调用&amp;事务"></a>6 外部调用&amp;事务</h1><h1 id="参数资料："><a href="#参数资料：" class="headerlink" title="参数资料："></a>参数资料：</h1><ol>
<li><p><a href="https://spring.io/projects/spring-statemachine" target="_blank" rel="noopener">https://spring.io/projects/spring-statemachine</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-statemachine/docs/2.2.0.RELEASE/reference/" target="_blank" rel="noopener">https://docs.spring.io/spring-statemachine/docs/2.2.0.RELEASE/reference/</a></p>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-Dubbo的集群策略（Cluster）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/20/Dubbo%E7%9A%84%E9%9B%86%E7%BE%A4%E7%AD%96%E7%95%A5%EF%BC%88Cluster%EF%BC%89/"
    >Dubbo的集群策略（Cluster）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/20/Dubbo%E7%9A%84%E9%9B%86%E7%BE%A4%E7%AD%96%E7%95%A5%EF%BC%88Cluster%EF%BC%89/" class="article-date">
  <time datetime="2020-06-19T19:21:47.000Z" itemprop="datePublished">2020-06-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dubbo/">Dubbo</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-Dubbo集群容错"><a href="#1-Dubbo集群容错" class="headerlink" title="1 Dubbo集群容错"></a>1 Dubbo集群容错</h1><p> Dubbo 集群容错方面的源码。集群容错源码包含四个部分，分别是服务目录 Directory、服务路由 Router、集群 Cluster 和负载均衡 LoadBalance</p>
<h1 id="2-Dubbo集群容错源码分析"><a href="#2-Dubbo集群容错源码分析" class="headerlink" title="2 Dubbo集群容错源码分析"></a>2 Dubbo集群容错源码分析</h1><p>集群容错接口如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cluster. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;a href="http://en.wikipedia.org/wiki/Computer_cluster"&gt;Cluster&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * &lt;a href="http://en.wikipedia.org/wiki/Fault-tolerant_system"&gt;Fault-Tolerant&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(FailoverCluster.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge the directory invokers to a virtual invoker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cluster invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看出，集群容错的主要功能时在服务字典中选择一个Invoker返回给调用者。默认的容错策略是故障转移策略（FailoverCluster）。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-Dubbo服务字典源码分析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/20/Dubbo%E6%9C%8D%E5%8A%A1%E5%AD%97%E5%85%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
    >Dubbo服务字典源码分析</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/20/Dubbo%E6%9C%8D%E5%8A%A1%E5%AD%97%E5%85%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-06-19T19:03:52.000Z" itemprop="datePublished">2020-06-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dubbo/">Dubbo</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-dubbo服务字典"><a href="#1-dubbo服务字典" class="headerlink" title="1 dubbo服务字典"></a>1 dubbo服务字典</h1><p>服务目录中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如ip、端口、服务协议等。通过这些信息，服务消费者就可通过Netty等客户端进行远程调用。</p>
<p>实际上服务目录在获取注册中心的服务配置信息后，会为每条配置信息生成一个Invoker对象，并把这个Invoker对象存储起来，这个Invoker才是服务目录最终持有的对象</p>
<p>Invoker是一个具有远程调用功能的对象，可以看做是Invoker集合，且这个集合中的元素会随注册中心的变化而进行动态调整。</p>
<p>分析代码的版本是</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="2-dubbo服务字典的源码分析"><a href="#2-dubbo服务字典的源码分析" class="headerlink" title="2 dubbo服务字典的源码分析"></a>2 dubbo服务字典的源码分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Directory. (SPI, Prototype, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;a href="http://en.wikipedia.org/wiki/Directory_service"&gt;Directory Service&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.dubbo.rpc.cluster.Cluster#join(Directory)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Directory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get service type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service type.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list invokers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invokers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; getAllInvokers();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面显示的是服务字典的接口，有接口可以看到Directory<T>接口提供的功能主要是以返回invoker列表，或者是返回服务的类型（Class<T>是对象的类型）</T></T></p>
<p><img src="/Daniel-Brute.github.io/2020/06/20/Dubbo%E6%9C%8D%E5%8A%A1%E5%AD%97%E5%85%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arch.png" alt></p>
<p>由上图可知，在图中Directory<T>有两个具体实现类RegistryDirectory<T>和StaticDirectory<T>，和一个抽象实现类AbstractDirectory<T>，那么这些类具体是干什么的呢？下面我们来分析一下</T></T></T></T></p>
<h2 id="2-1-AbstractDirectory"><a href="#2-1-AbstractDirectory" class="headerlink" title="2.1 AbstractDirectory"></a>2.1 AbstractDirectory<T></T></h2><p>抽象类AbstractDirectory<T>是Directory<T>的实现，实现了Directory<T>的一些公共方法。</T></T></T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroyed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者URL</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> URL consumerUrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储了所有的RouterFactory对象，通过RouterFactory可以创建出Router对象</span></span><br><span class="line"><span class="keyword">protected</span> RouterChain&lt;T&gt; routerChain;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, URL consumerUrl, RouterChain&lt;T&gt; routerChain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//url协议中是否有registry或者service-discovery-registry</span></span><br><span class="line">    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">        <span class="comment">// 获取refer对应的参数：a=b&amp;c=d</span></span><br><span class="line">        Map&lt;String, String&gt; queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">        <span class="comment">// 将refer的参数添加到url中，并且移除monitor的参数</span></span><br><span class="line">        <span class="keyword">this</span>.url = url.addParameters(queryMap).removeParameter(MONITOR_KEY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.consumerUrl = consumerUrl;</span><br><span class="line">    <span class="comment">// 给routerChain赋值</span></span><br><span class="line">    setRouterChain(routerChain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Directory already destroyed .url: "</span> + getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line">    <span class="keyword">return</span> doList(invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有上面的代码可以看出抽象类AbstractDirectory<T>只是做了一些参数的初始化工作，具体的实现功能还是由子类的doList方法实现</T></p>
<h2 id="2-2-RegistryDirectory"><a href="#2-2-RegistryDirectory" class="headerlink" title="2.2 RegistryDirectory"></a>2.2 RegistryDirectory<T></T></h2><ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RegistryDirectory</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (serviceType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service type is null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url.getServiceKey() == <span class="keyword">null</span> || url.getServiceKey().length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"registry serviceKey is null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.serviceType = serviceType;</span><br><span class="line">    <span class="keyword">this</span>.serviceKey = url.getServiceKey();</span><br><span class="line">    <span class="keyword">this</span>.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">    <span class="keyword">this</span>.overrideDirectoryUrl = <span class="keyword">this</span>.directoryUrl = turnRegistryUrlToConsumerUrl(url);</span><br><span class="line">    String group = directoryUrl.getParameter(GROUP_KEY, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">this</span>.multiGroup = group != <span class="keyword">null</span> &amp;&amp; (ANY_VALUE.equals(group) || group.contains(<span class="string">","</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RegistryDirectory除了使用父类初始化url，还初始化了一些本类的对象这些对象是干什么的呢？</p>
<p>当注册中心的配置参数发生变化时，RegistryDirectory会第一时间感应到变化，并且将注册中心的url拉取到本地。这是一个动态的过程，订阅、通知和刷新本地的invoker的代码如下：</p>
<ul>
<li>订阅<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    setConsumerUrl(url);</span><br><span class="line">    CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(<span class="keyword">this</span>);</span><br><span class="line">    serviceConfigurationListener = <span class="keyword">new</span> ReferenceConfigurationListener(<span class="keyword">this</span>, url);</span><br><span class="line">    registry.subscribe(url, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>接收服务变更通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按照策略过滤url并且按照类型将其分组</span></span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .filter(<span class="keyword">this</span>::isValidCategory)</span><br><span class="line">            .filter(<span class="keyword">this</span>::isNotCompatibleFor26x)</span><br><span class="line">            .collect(Collectors.groupingBy(url -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isConfigurator(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> CONFIGURATORS_CATEGORY;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isRoute(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ROUTERS_CATEGORY;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isProvider(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> PROVIDERS_CATEGORY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;));</span><br><span class="line">    <span class="comment">// 配置中心的url处理</span></span><br><span class="line">    List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="keyword">this</span>.configurators = Configurator.toConfigurators(configuratorURLs).orElse(<span class="keyword">this</span>.configurators);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路由的url处理</span></span><br><span class="line">    List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="comment">// 获取url的可路由信息，并且将路由列表存放在父类的routerChain中。</span></span><br><span class="line">    toRouters(routerURLs).ifPresent(<span class="keyword">this</span>::addRouters);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务提供者的url处理</span></span><br><span class="line">    List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.x added for extend URL address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ExtensionLoader&lt;AddressListener&gt; addressListenerExtensionLoader = ExtensionLoader.getExtensionLoader(AddressListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;AddressListener&gt; supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (supportedListeners != <span class="keyword">null</span> &amp;&amp; !supportedListeners.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AddressListener addressListener : supportedListeners) &#123;</span><br><span class="line">            <span class="comment">// 通知服务提供者的url列表发生变化</span></span><br><span class="line">            providerURLs = addressListener.notify(providerURLs, getUrl(),<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖本地原有的配置并且刷新invoker列表</span></span><br><span class="line">    refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新服务的通知列表</p>
</li>
</ul>
<p>refreshInvoker方法经过refreshOverrideAndInvoker方法调用，在调用之前会调用overrideDirectoryUrl方法覆盖现有缓存中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 将invokerURL转换成Invoker Map，转换规则如下所示：</span></span><br><span class="line"><span class="comment"> * 1. 如果URL已转换为invoker，则不再重新引用它并直接从缓存获取它，请注意URL中的任何参数更改都将被重新引用。</span></span><br><span class="line"><span class="comment"> * 2. 如果传入的invoker列表不为空，则表示它是最新的invoker列表</span></span><br><span class="line"><span class="comment"> * 3. 如果传入invokerUrl的列表为空，则意味着该规则只是一个重写规则或路由规则，需要对其进行重新对比以决定是否重新引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 2017/8/31 FIXME 应该使用线程池刷新地址，否则任务可能会累积。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(invokerUrls, <span class="string">"invokerUrls should not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前未获取到 invokerUrls，则清空所有的本地invokers</span></span><br><span class="line">    <span class="keyword">if</span> (invokerUrls.size() == <span class="number">1</span></span><br><span class="line">            &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>; <span class="comment">// Forbid to access</span></span><br><span class="line">        <span class="keyword">this</span>.invokers = Collections.emptyList();</span><br><span class="line">        routerChain.setInvokers(<span class="keyword">this</span>.invokers);</span><br><span class="line">        destroyAllInvokers(); <span class="comment">// Close all invokers</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; <span class="comment">// Allow to access</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        <span class="keyword">if</span> (invokerUrls == Collections.&lt;URL&gt;emptyList()) &#123;</span><br><span class="line">            invokerUrls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 本地缓存的invoker的url，便于比较</span></span><br><span class="line">            <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将url列表转换为Invoker的map</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// Translate url list to Invoker map</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果计算错误，则不进行处理：</span></span><br><span class="line"><span class="comment">         * 1. 客户端配置的协议与服务器的协议不一致。例如，消费者端使用dubbo协议，服务提供段使用其他的协议。</span></span><br><span class="line"><span class="comment">         * 2. 注册中心不健壮，推送非法规范数据。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmptyMap(newUrlInvokerMap)) &#123;</span><br><span class="line">            logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"urls to invokers error .invokerUrls.size :"</span> + invokerUrls.size() + <span class="string">", invoker.size :0. urls :"</span> + invokerUrls</span><br><span class="line">                    .toString()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; newInvokers = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(newUrlInvokerMap.values()));</span><br><span class="line">        <span class="comment">// 预路由和构建缓存，注意路由缓存应该构建在原始调用程序列表上。</span></span><br><span class="line">        <span class="comment">// toMergeMethodInvokerMap()将包装一些具有不同组的invokers，包装的invokers不应被路由。</span></span><br><span class="line">        routerChain.setInvokers(newInvokers);</span><br><span class="line">        <span class="keyword">this</span>.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</span><br><span class="line">        <span class="comment">// 将新建立的invoker放在本地缓存中</span></span><br><span class="line">        <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 删除一些不再使用的invoker</span></span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"destroyUnusedInvokers error. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到刷新Invoker列表的核心功能是将url列表转换为Invoker的map，即toInvokers方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将服务提供者的url转换为invokers，如果url已被引用，则不会重新引用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> invokers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    String queryProtocols = <span class="keyword">this</span>.queryMap.get(PROTOCOL_KEY);</span><br><span class="line">    <span class="comment">// 遍历服务提供者的url</span></span><br><span class="line">    <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">        <span class="comment">// If protocol is configured at the reference side, only the matching protocol is selected</span></span><br><span class="line">        <span class="comment">// 如果消费者端已经配置了协议，只选择已经匹配的协议</span></span><br><span class="line">        <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">            String[] acceptProtocols = queryProtocols.split(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                    accept = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果配置的协议为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前的协议是否正在使用</span></span><br><span class="line">        <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">providerUrl</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">            logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported protocol "</span> + providerUrl.getProtocol() +</span><br><span class="line">                    <span class="string">" in notified url: "</span> + providerUrl + <span class="string">" from registry "</span> + getUrl().getAddress() +</span><br><span class="line">                    <span class="string">" to consumer "</span> + NetUtils.getLocalHost() + <span class="string">", supported protocol: "</span> +</span><br><span class="line">                    ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()))</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并url参数，顺序是：overide &gt; -D配置 &gt; 消费者 &gt; 服务提供者</span></span><br><span class="line">        URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">        String key = url.toFullString(); <span class="comment">// The parameter urls are sorted</span></span><br><span class="line">        <span class="comment">// 如果url已经处理过，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (keys.contains(key)) &#123; <span class="comment">// Repeated url</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.add(key);</span><br><span class="line">        <span class="comment">//Cache Key是不与使用者端参数合并的url，无论使用者如何组合参数，如果服务器url改变，则再次引用</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">        <span class="comment">// url是新增的</span></span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 解析配置参数disabled，当前的url是否创建新的invoker</span></span><br><span class="line">                <span class="keyword">if</span> (url.hasParameter(DISABLED_KEY)) &#123;</span><br><span class="line">                    enabled = !url.getParameter(DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    enabled = url.getParameter(ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果允许创建（默认是允许），创建invoker</span></span><br><span class="line">                <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                    invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果新创建的invoker不为空，则放在缓存中返回</span></span><br><span class="line">            <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newUrlInvokerMap.put(key, invoker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.clear();</span><br><span class="line">    <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>doList</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (forbidden) &#123;</span><br><span class="line">        <span class="comment">// 1. No service provider 2. Service providers are disabled</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION, <span class="string">"No provider available from registry "</span> +</span><br><span class="line">                getUrl().getAddress() + <span class="string">" for service "</span> + getConsumerUrl().getServiceKey() + <span class="string">" on consumer "</span> +</span><br><span class="line">                NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() +</span><br><span class="line">                <span class="string">", please check status of providers(disabled, not registered or in blacklist)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multiGroup) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.invokers == <span class="keyword">null</span> ? Collections.emptyList() : <span class="keyword">this</span>.invokers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从缓存中获取invokers, 并且只有运行时的invokers会被执行。</span></span><br><span class="line">        invokers = routerChain. (getConsumerUrl(), invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Failed to execute router: "</span> + getUrl() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> invokers == <span class="keyword">null</span> ? Collections.emptyList() : invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出RegistryDirectory<T>的核心功能就是将invocation和消费者的url交给路由模块去处理。</T></p>
<h2 id="2-3-StaticDirectory"><a href="#2-3-StaticDirectory" class="headerlink" title="2.3 StaticDirectory"></a>2.3 StaticDirectory<T></T></h2><ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers, RouterChain&lt;T&gt; routerChain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url == <span class="keyword">null</span> &amp;&amp; CollectionUtils.isNotEmpty(invokers) ? invokers.get(<span class="number">0</span>).getUrl() : url, routerChain);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invokers == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由上面的代码可以看出，RegistryDirectory<T>方法初始化了父类的url和routerChain</T></p>
<ul>
<li>doList</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; finalInvokers = invokers;</span><br><span class="line">    <span class="keyword">if</span> (routerChain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            finalInvokers = routerChain.route(getConsumerUrl(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to execute router: "</span> + getUrl() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finalInvokers == <span class="keyword">null</span> ? Collections.emptyList() : finalInvokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出RegistryDirectory<T>的核心功能就是将invocation和消费者的url交给路由模块去处理。</T></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-Dubbo负载均衡机制和源码分析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/18/Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
    >Dubbo负载均衡机制和源码分析</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/18/Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-06-17T23:12:02.000Z" itemprop="datePublished">2020-06-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dubbo/">Dubbo</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-dubbo负载均衡"><a href="#1-dubbo负载均衡" class="headerlink" title="1 dubbo负载均衡"></a>1 dubbo负载均衡</h1><p>负载均衡是一种对服务请求按照既定的访问策略，将请求发放到不同的服务器上，其目的是将服务发放到一些特定地机器上，达到服务资源和计算机资源合理利用的目的，即使得每个计算机上的负载达到均衡。</p>
<p>当前分析的负载均衡的dubbo的版本是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-负载均衡的源码实现"><a href="#2-负载均衡的源码实现" class="headerlink" title="2 负载均衡的源码实现"></a>2 负载均衡的源码实现</h1><h2 id="2-1-接口定义"><a href="#2-1-接口定义" class="headerlink" title="2.1 接口定义"></a>2.1 接口定义</h2><p>在dubbo 2.7.5中，负载均衡的接口如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LoadBalance. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;a href="http://en.wikipedia.org/wiki/Load_balancing_(computing)"&gt;Load-Balancing&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.dubbo.rpc.cluster.Cluster#join(Directory)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(RandomLoadBalance.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * select one invoker in list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(<span class="string">"loadbalance"</span>)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出负载均衡的加载机制使用的是SPI机制，且默认的使用的是随机的负载均衡加载策略：</p>
<p>@Adaptive(“loadbalance”)说明了根据配置参数loadbalance传入的值可以自适应地选择不同的负载均衡策略。</p>
<p>在dubbo中LoadBalance接口有一个默认的LoadBalance实现类，即AbstractLoadBalance方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据预热时间的正常运行时间比例计算权重，新权重将在1（含）到weight（含）之间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uptime 正常运行时间（毫秒级）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> warmup 预热时间（毫秒级）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 一个invoker的权重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 预热权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ww = (<span class="keyword">int</span>) ( uptime / ((<span class="keyword">float</span>) warmup / weight));</span><br><span class="line">        <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (Math.min(ww, weight));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个invoker时，直接返回，不需要负载均衡</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由子类实现doSelect钩子方法进行负载均衡</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果运行时间小于预热时间 ，获取invoker的预热权重，权重会按比例减少。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker    the invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 当前invoker的调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="comment">// Multiple registry scenario, load balance among multiple registries.</span></span><br><span class="line">        <span class="comment">// 如果是多注册表场景，需要做多个注册表之间的负载平衡。</span></span><br><span class="line">        <span class="keyword">if</span> (url.getServiceInterface().equals(<span class="string">"org.apache.dubbo.registry.RegistryService"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获取registry.weight值，如果不存在，默认是100</span></span><br><span class="line">            weight = url.getParameter(REGISTRY_KEY + <span class="string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是单场景注册，获取权重值</span></span><br><span class="line">            weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">            <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取timestamp参数值</span></span><br><span class="line">                <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">                <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获得运行时间</span></span><br><span class="line">                    <span class="keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span><br><span class="line">                    <span class="keyword">if</span> (uptime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取预热参数值</span></span><br><span class="line">                    <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span><br><span class="line">                    <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                        <span class="comment">// 计算获得预热权重</span></span><br><span class="line">                        weight = calculateWarmupWeight((<span class="keyword">int</span>)uptime, warmup, weight);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(weight, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到AbstractLoadBalance里面实现了当程序运行时，可以在预热期间获得权重值，即在运行之初，会减小当前Invoker分配到url中的参数，进而运行服务运行权的权重。</p>
<p>为什么要预热，jvm运行时会对字节码进行优化，刚启动的字节码肯定不是最优的。或者是提供者本身有其他缓存需要初始化之类的。所以预热是有必要的。不能一启动就和其他提供者承受同样流量，可能效率会变慢。</p>
<h2 id="2-2-LoadBalance在dubbo中的位置"><a href="#2-2-LoadBalance在dubbo中的位置" class="headerlink" title="2.2 LoadBalance在dubbo中的位置"></a>2.2 LoadBalance在dubbo中的位置</h2><p><img src="/Daniel-Brute.github.io/2020/06/18/Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arch.png" alt></p>
<p>由LoadBalance接口中的@see可以看出，负载均衡的调用是在Cluster的join(Directory)方法中使用。</p>
<h2 id="2-3-dubbo中其他的LoadBalanceWW"><a href="#2-3-dubbo中其他的LoadBalanceWW" class="headerlink" title="2.3 dubbo中其他的LoadBalanceWW"></a>2.3 dubbo中其他的LoadBalanceWW</h2><p>dubbo中有四种负载均衡的测录，但是均继承于AbstractLoadBalance抽象类，</p>
<ul>
<li>1）随机负载均衡</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class select one provider from multiple providers randomly.</span></span><br><span class="line"><span class="comment"> * You can define weights for each provider:</span></span><br><span class="line"><span class="comment"> * If the weights are all the same then it will use random.nextInt(number of invokers).</span></span><br><span class="line"><span class="comment"> * If the weights are different then it will use random.nextInt(w1 + w2 + ... + wn)</span></span><br><span class="line"><span class="comment"> * Note that if the performance of the machine is better than others, you can set a larger weight.</span></span><br><span class="line"><span class="comment"> * If the performance is not so good, you can set a smaller weight.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"random"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用随机策略在一个列表中选择一个invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers 可能被选择的invokers列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被选择的invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// 是否是每个invoker都有相同的权重？</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 存储每个invoker的权重</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> firstWeight = getWeight(invokers.get(<span class="number">0</span>), invocation);</span><br><span class="line">        weights[<span class="number">0</span>] = firstWeight;</span><br><span class="line">        <span class="comment">// 存储所有的invoker权重的总和</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = firstWeight;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">            <span class="comment">// save for later use</span></span><br><span class="line">            weights[i] = weight;</span><br><span class="line">            <span class="comment">// Sum</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个invoker的权重都是不相同的，生成一个随机数offset，返回随机数落在的invoker权重区间的invoker。</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 生成随机数</span></span><br><span class="line">            <span class="keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 找到随机数落到的invoker权重区间的invoker</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                offset -= weights[i];</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有的invoker都是一样的，或者totalWeight为0，则随机返回一个involer。</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2）一致性Hash负载均衡</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"consistenthash"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash节点名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_NODES = <span class="string">"hash.nodes"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash参数名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_ARGUMENTS = <span class="string">"hash.arguments"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + methodName;</span><br><span class="line">        <span class="keyword">int</span> identityHashCode = System.identityHashCode(invokers);</span><br><span class="line">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">            selectors.put(key, <span class="keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一致性hash选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//hash环，hash值与虚拟节点的映射</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">        <span class="comment">// 每个invoker的虚拟节点数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replicaNumber;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityHashCode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] argumentIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化hash虚拟节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="keyword">int</span> identityHashCode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">            URL url = invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line">            <span class="comment">// 获取虚拟节点数，默认160个节点，配置例子 &lt;dubbo:parameter key="hash.nodes" value="320" /&gt;</span></span><br><span class="line">            <span class="keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="number">160</span>);</span><br><span class="line">            <span class="comment">// 获取需要hash的参数位置。配置例子&lt;dubbo:parameter key="hash.arguments" value="0,1" /&gt; 默认只hash第一个，0位置参数</span></span><br><span class="line">            String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="string">"0"</span>));</span><br><span class="line">            argumentIndex = <span class="keyword">new</span> <span class="keyword">int</span>[index.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">                argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                <span class="comment">// 获取提供者host:port形式地址</span></span><br><span class="line">                String address = invoker.getUrl().getAddress();</span><br><span class="line">                <span class="comment">// 每个再分别hash 4次，这样每个机器就虚拟了160份</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] digest = md5(address + i);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                        <span class="comment">// 160份虚拟节点，每一份都映射同一个实际节点</span></span><br><span class="line">                        <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line">                        virtualInvokers.put(m, invoker);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 在virtualInvokers中选择一个可用节点返回</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">            String key = toKey(invocation.getArguments());</span><br><span class="line">            <span class="comment">// 对拼接后的参数做MD5指纹摘要</span></span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">            <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 拼接参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">toKey</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : argumentIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                    buf.append(args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 根据hash值，选择invoker方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 返回hash对应的&lt;key, value&gt;，如果不存在，则返回小于指定键的最大键的项</span></span><br><span class="line">            Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 取虚拟节点第一个(key值最小的节点）</span></span><br><span class="line">                entry = virtualInvokers.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取key映射的实际invoker</span></span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 计算hash值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(<span class="keyword">byte</span>[] digest, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 一共32位</span></span><br><span class="line">            <span class="keyword">return</span> (((<span class="keyword">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                    | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                    | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                    | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">                    &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 计算md5值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] md5(String value) &#123;</span><br><span class="line">            MessageDigest md5;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            md5.reset();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = value.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            md5.update(bytes);</span><br><span class="line">            <span class="keyword">return</span> md5.digest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3）最少使用优先负载均衡</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LeastActiveLoadBalance</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Filter the number of invokers with the least number of active calls and count the weights and quantities of these invokers.</span></span><br><span class="line"><span class="comment"> * If there is only one invoker, use the invoker directly;</span></span><br><span class="line"><span class="comment"> * if there are multiple invokers and the weights are not the same, then random according to the total weight;</span></span><br><span class="line"><span class="comment"> * if there are multiple invokers and the same weight, then randomly called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"leastactive"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// 最小活跃度</span></span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最小活跃度的invokers个数</span></span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 拥有相同最小活跃度invokers的索引。</span></span><br><span class="line">        <span class="keyword">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// 所有invokers的权重的索引</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 是否所有的invokers都是相同的活跃度</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤所欲最小活跃度的invokers</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            <span class="comment">// 获取活跃的invokers的个数</span></span><br><span class="line">            <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="comment">// 第一个invoker的活跃度，或者当前的invoker的活跃度小于当前的最小活跃度时</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                leastActive = active;</span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="comment">// If every invoker has the same weight?</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Choose an invoker from all the least active invokers</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// If we got exactly one invoker having the least active value, return this invoker directly.</span></span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是所有的invoker都含有相同的weight且至少有一个最小活跃的invoker的weight大于0，则在这些最小活跃度的invoker中随机选一个。</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有invokers拥有相同的weight或者totalWeight为0，则随机放回一个</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4）轮询负载均衡</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"roundrobin"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECYCLE_PERIOD = <span class="number">60000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedRoundRobin</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 权重</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="comment">// 轮询值</span></span><br><span class="line">        <span class="keyword">private</span> AtomicLong current = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 权重最后一次更新时间</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastUpdate;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sel</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">            current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdate</span><span class="params">(<span class="keyword">long</span> lastUpdate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &lt;服务标识，&lt;服务所在机器标识，服务轮询值&gt;&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean updateLock = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get invoker addr list cached for specified invocation</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;for unit test only&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Collection&lt;String&gt; <span class="title">getInvokerAddrList</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</span><br><span class="line">        Map&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拼接key</span></span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            methodWeightMap.putIfAbsent(key, <span class="keyword">new</span> ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;());</span><br><span class="line">            map = methodWeightMap.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>; <span class="comment">//？</span></span><br><span class="line">        <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 定义一个指向最终服务提供者的selectedInvoker，和对应的selectedWRR轮询对象。</span></span><br><span class="line">        Invoker&lt;T&gt; selectedInvoker = <span class="keyword">null</span>;</span><br><span class="line">        WeightedRoundRobin selectedWRR = <span class="keyword">null</span>; <span class="comment">//？</span></span><br><span class="line">        <span class="comment">// 便利所有的 invokers</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 获取每个invoker的唯一标识字符串</span></span><br><span class="line">            String identifyString = invoker.getUrl().toIdentityString();</span><br><span class="line">            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invoker, invocation);</span><br><span class="line">            <span class="comment">// 如果缓存中没有当前invoker的权重，则新创建一个</span></span><br><span class="line">            <span class="keyword">if</span> (weightedRoundRobin == <span class="keyword">null</span>) &#123;</span><br><span class="line">                weightedRoundRobin = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">                map.putIfAbsent(identifyString, weightedRoundRobin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果计算出的权重值和当前缓存中的权重值不一样，更新缓存</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取得到当前的轮询对象之后，进行原子自增操作，记录操作时间，这个时候就要判断轮询原子值是否大于maxCurrent的值了</span></span><br><span class="line">            <span class="keyword">long</span> cur = weightedRoundRobin.increaseCurrent();</span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">// 如果大于证明当前这个服务提供者的Invoker是有效的</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = cur;</span><br><span class="line">                selectedInvoker = invoker;</span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优化代码 是为了在有Invoker下线，或者服务不可用的时候，将其从轮询队列中剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!updateLock.get() &amp;&amp; invokers.size() != map.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (updateLock.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// copy -&gt; modify -&gt; update reference</span></span><br><span class="line">                    ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(map);</span><br><span class="line">                    <span class="comment">// 删除大于60000的更新时间</span></span><br><span class="line">                    newMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">                    methodWeightMap.put(key, newMap);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.set(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><blockquote>
<ol>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html</a></li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><a href="https://github.com/apache/dubbo/tree/dubbo-2.7.5">https://github.com/apache/dubbo/tree/dubbo-2.7.5</a></li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><a href="https://www.jianshu.com/p/fa1f101b4d23" target="_blank" rel="noopener">https://www.jianshu.com/p/fa1f101b4d23</a></li>
</ol>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-Dubbo路由规则和源码分析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/18/Dubbo%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
    >Dubbo路由规则和源码分析</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/18/Dubbo%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-06-17T23:11:39.000Z" itemprop="datePublished">2020-06-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dubbo/">Dubbo</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-dubbo路由配置"><a href="#1-dubbo路由配置" class="headerlink" title="1 dubbo路由配置"></a>1 dubbo路由配置</h1><p>服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者。</p>
<p>分析代码的版本是</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/Daniel-Brute.github.io/2020/06/18/Dubbo%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arch.png" alt></p>
<h1 id="2-路由的源码实现"><a href="#2-路由的源码实现" class="headerlink" title="2 路由的源码实现"></a>2 路由的源码实现</h1><p>路由的接口如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Router</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_PRIORITY = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用当前路由规则筛选调用服务程序，并仅返回符合该规则调用的服务程序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知路由器调用服务程序列表。调用服务程序列表可能会不时更改。此方法使路由器有机会在调用&#123;<span class="doctag">@link</span> Router#route(List, URL, Invocation)&#125;之前 进行准备。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 决定此路由器是否需要在每次出现RPC时执行，或者只应在地址或规则更改时执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 如果路由器每次需要执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当调用程序都不能匹配路由器规则时，决定此路由器是否应生效，这意味着&#123;<span class="doctag">@link</span> #route(List, URL, Invocation)&#125;将为空。大多数情况下，大多数路由器实现都会将此值默认为false。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 如果没有调用程序与当前路由器匹配则执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isForce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由器的优先级，用于路由器排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> router的优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 路由器的优先级比较函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Router o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.getPriority(), o.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Router的抽象实现类的核心如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认优先级</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> priority = DEFAULT_PRIORITY;</span><br><span class="line"><span class="comment">// 路由规则失效时，返回null</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> force = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">protected</span> URL url;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置中心</span></span><br><span class="line"><span class="keyword">protected</span> GovernanceRuleRepository ruleRepository;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ruleRepository = ExtensionLoader.getExtensionLoader(GovernanceRuleRepository<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看到，路由提供的公共方法是将url缓存到本地的配置中心。接下来我们看一下路由的具体实现。</p>
<h2 id="2-1-条件路由（ConditionRouter）"><a href="#2-1-条件路由（ConditionRouter）" class="headerlink" title="2.1 条件路由（ConditionRouter）"></a>2.1 条件路由（ConditionRouter）</h2><ul>
<li>初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"condition"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ConditionRouter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROUTE_PATTERN = Pattern.compile(<span class="string">"([&amp;!=,]*)\\s*([^&amp;!=,\\s]+)"</span>);</span><br><span class="line"><span class="comment">// 解析服务消费者匹配规则</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, MatchPair&gt; whenCondition;</span><br><span class="line"><span class="comment">// 解析服务提供者匹配规则</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, MatchPair&gt; thenCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConditionRouter</span><span class="params">(String rule, <span class="keyword">boolean</span> force, <span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.force = force;</span><br><span class="line">    <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    <span class="keyword">this</span>.init(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConditionRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="comment">// 获取配置参数</span></span><br><span class="line">    <span class="keyword">this</span>.priority = url.getParameter(PRIORITY_KEY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.force = url.getParameter(FORCE_KEY, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.enabled = url.getParameter(ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 获取路由规则并且初始化参数</span></span><br><span class="line">    init(url.getParameterAndDecoded(RULE_KEY));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String rule)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rule == <span class="keyword">null</span> || rule.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal route rule!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rule = rule.replace(<span class="string">"consumer."</span>, <span class="string">""</span>).replace(<span class="string">"provider."</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 定位分隔符，前面是consumer规则，后面是provider规则</span></span><br><span class="line">        <span class="keyword">int</span> i = rule.indexOf(<span class="string">"=&gt;"</span>);</span><br><span class="line">        <span class="comment">// 获取消费者和服务者的规则字符串</span></span><br><span class="line">        String whenRule = i &lt; <span class="number">0</span> ? <span class="keyword">null</span> : rule.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">        String thenRule = i &lt; <span class="number">0</span> ? rule.trim() : rule.substring(i + <span class="number">2</span>).trim();</span><br><span class="line">        <span class="comment">// 解析规则，并且封装成map</span></span><br><span class="line">        Map&lt;String, MatchPair&gt; when = StringUtils.isBlank(whenRule) || <span class="string">"true"</span>.equals(whenRule) ? <span class="keyword">new</span> HashMap&lt;String, MatchPair&gt;() : parseRule(whenRule);</span><br><span class="line">        Map&lt;String, MatchPair&gt; then = StringUtils.isBlank(thenRule) || <span class="string">"false"</span>.equals(thenRule) ? <span class="keyword">null</span> : parseRule(thenRule);</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> 应该在业务级别确定“When条件”是否可以为空</span></span><br><span class="line">        <span class="keyword">this</span>.whenCondition = when;</span><br><span class="line">        <span class="keyword">this</span>.thenCondition = then;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析规则</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过正则表达式匹配路由规则，ROUTE_PATTERN = ([&amp;!=,]*)\s*([^&amp;!=,\s]+)</span></span><br><span class="line"><span class="comment"> * 这个表达式看起来不是很好理解，第一个括号内的表达式用于匹配"&amp;", "!", "=" 和 "," 等符号。</span></span><br><span class="line"><span class="comment"> * 第二括号内的用于匹配英文字母，数字等字符。举个例子说明一下：</span></span><br><span class="line"><span class="comment"> *   host = 2.2.2.2 &amp; host != 1.1.1.1 &amp; method = hello</span></span><br><span class="line"><span class="comment"> * 匹配结果如下：</span></span><br><span class="line"><span class="comment"> *     括号一      括号二</span></span><br><span class="line"><span class="comment"> * 1.  null       host</span></span><br><span class="line"><span class="comment"> * 2.   =         2.2.2.2</span></span><br><span class="line"><span class="comment"> * 3.   &amp;         host</span></span><br><span class="line"><span class="comment"> * 4.   !=        1.1.1.1</span></span><br><span class="line"><span class="comment"> * 5.   &amp;         method</span></span><br><span class="line"><span class="comment"> * 6.   =         hello</span></span><br><span class="line"><span class="comment"> * 只解析服务消费者或者生产者的规则，两个对象的契约模式相同</span></span><br><span class="line"><span class="comment"> * rule举例：host !=4.4.4.4 &amp; host = 2.2.2.2,1.1.1.1,3.3.3.3 &amp;method =sayHello =&gt; host = 1.2.3.4&amp;host !=4.4.4.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MatchPair&gt; <span class="title">parseRule</span><span class="params">(String rule)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    Map&lt;String, MatchPair&gt; condition = <span class="keyword">new</span> HashMap&lt;String, MatchPair&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(rule)) &#123;</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配参数的Key-Value值</span></span><br><span class="line">    MatchPair pair = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Multiple values</span></span><br><span class="line">    Set&lt;String&gt; values = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 规则字符串正则表达式匹配</span></span><br><span class="line">    <span class="keyword">final</span> Matcher matcher = ROUTE_PATTERN.matcher(rule);</span><br><span class="line">    <span class="comment">// 分析每个匹配项，一个括号一个匹配</span></span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        String separator = matcher.group(<span class="number">1</span>);</span><br><span class="line">        String content = matcher.group(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 第一次匹配字符串</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(separator)) &#123;</span><br><span class="line">            pair = <span class="keyword">new</span> MatchPair();</span><br><span class="line">            condition.put(content, pair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"&amp;"</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (condition.get(content) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pair = <span class="keyword">new</span> MatchPair();</span><br><span class="line">                condition.put(content, pair);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pair = condition.get(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// value值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"="</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Illegal route rule \""</span> + rule + <span class="string">"\", The error char '"</span> + separator  <span class="string">"' at index "</span> + matcher.start() + <span class="string">" before \""</span> + content + <span class="string">"\"."</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            values = pair.matches;</span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不匹配的value值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"!="</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Illegal route rule \""</span> + rule + <span class="string">"\", The error char '"</span> + separator + <span class="string">"' at index "</span> + matcher.start() + <span class="string">" before \""</span> + content + <span class="string">"\"."</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">            values = pair.mismatches;</span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// value值的枚举</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">","</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Illegal route rule \""</span> + rule + <span class="string">"\", The error char '"</span> + separator + <span class="string">"' at index "</span> + matcher.start() + <span class="string">" before \""</span> + content + <span class="string">"\"."</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Illegal route rule \""</span> + rule + <span class="string">"\", The error char '"</span> + separator + <span class="string">"' at index "</span> + matcher.start() + <span class="string">" before \""</span> + content + <span class="string">"\"."</span>, matcher.start());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> condition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span><br><span class="line">        <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前置条件不匹配，说明consumer不在限制之列</span></span><br><span class="line">        <span class="keyword">if</span> (!matchWhen(url, invocation)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="comment">// thenCondition为null表示拒绝一切请求</span></span><br><span class="line">        <span class="keyword">if</span> (thenCondition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"The current consumer in the service blacklist. consumer: "</span> + NetUtils.getLocalHost() + <span class="string">", service: "</span> + url.getServiceKey());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 调用方匹配才放行。服务提供者，只要符合路由才能提供服务，这里的url改为invoker.getUrl()都不匹配，这里result可能是空的。</span></span><br><span class="line">            <span class="keyword">if</span> (matchThen(invoker.getUrl(), url)) &#123;</span><br><span class="line">                result.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">            <span class="comment">// force强制执行路由。哪怕result是空的，也要返回给上层方法。如果为false,最后放回所有的invokers，等于不执行路由</span></span><br><span class="line">            logger.warn(<span class="string">"The route result is empty and force execute. consumer: "</span> + NetUtils.getLocalHost() + <span class="string">", service: "</span> + url.getServiceKey() + <span class="string">", router: "</span> + url.getParameterAndDecoded(RULE_KEY));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Failed to execute condition router rule: "</span> + getUrl() + <span class="string">", invokers: "</span> + invokers + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>匹配条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在进行路由调用时，会使用此方法对消费者和服务提供指的url和引用做条件规则过滤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchCondition</span><span class="params">(Map&lt;String, MatchPair&gt; condition, URL url, URL param, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取url中的参数：协议、用户名、密码、主机、端口和路径</span></span><br><span class="line">    Map&lt;String, String&gt; sample = url.toMap();</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, MatchPair&gt; matchPair : condition.entrySet()) &#123;</span><br><span class="line">        String key = matchPair.getKey();</span><br><span class="line">        String sampleValue;</span><br><span class="line">        <span class="comment">// 解析参数</span></span><br><span class="line">        <span class="keyword">if</span> (invocation != <span class="keyword">null</span> &amp;&amp; (METHOD_KEY.equals(key) || METHODS_KEY.equals(key))) &#123;</span><br><span class="line">            sampleValue = invocation.getMethodName();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ADDRESS_KEY.equals(key)) &#123;</span><br><span class="line">            sampleValue = url.getAddress();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HOST_KEY.equals(key)) &#123;</span><br><span class="line">            sampleValue = url.getHost();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sampleValue = sample.get(key);</span><br><span class="line">            <span class="keyword">if</span> (sampleValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sampleValue = sample.get(key); <span class="comment">//？</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sampleValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matchPair.getValue().isMatch(sampleValue, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//not pass the condition</span></span><br><span class="line">            <span class="keyword">if</span> (!matchPair.getValue().matches.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-脚本路由（ScriptRouter）"><a href="#2-2-脚本路由（ScriptRouter）" class="headerlink" title="2.2 脚本路由（ScriptRouter）"></a>2.2 脚本路由（ScriptRouter）</h2><ul>
<li>例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">invokers,invocation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">    <span class="comment">//读方法只调用192.168.207.88</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"read"</span>.equals(invocation.getMethodName())) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;invokers.size(); i++) &#123;    </span><br><span class="line">                <span class="keyword">if</span>(invokers.get(i).getUrl().getHost() ==<span class="string">"192.168.207.88"</span>) &#123;</span><br><span class="line">                    result.add(invokers.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"write"</span>.equals(invocation.getMethodName()))&#123;</span><br><span class="line">        <span class="comment">//写方法只调用192.168.112.12</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;invokers.size(); i++) &#123;    </span><br><span class="line">                <span class="keyword">if</span>(invokers.get(i).getUrl().getHost() ==<span class="string">"192.168.112.12"</span>) &#123;</span><br><span class="line">                    result.add(invokers.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;(invokers,invocation));</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"SCRIPT_ROUTER"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCRIPT_ROUTER_DEFAULT_PRIORITY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ScriptRouter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ScriptEngine&gt; engines = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过脚本中配置的脚本类型，获取对应的脚本处理引擎 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScriptEngine engine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url中脚本规则</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String rule;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译之后的脚本</span></span><br><span class="line"><span class="keyword">private</span> CompiledScript function;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScriptRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.priority = url.getParameter(PRIORITY_KEY, SCRIPT_ROUTER_DEFAULT_PRIORITY);</span><br><span class="line"></span><br><span class="line">    engine = getEngine(url);</span><br><span class="line">    rule = getRule(url);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将脚本编译成一种可以重复执行而无需重新编译的形式。</span></span><br><span class="line">        Compilable compilable = (Compilable) engine;</span><br><span class="line">        function = compilable.compile(rule);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ScriptException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"route error, rule has been ignored. rule: "</span> + rule +</span><br><span class="line">                <span class="string">", url: "</span> + RpcContext.getContext().getUrl(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过url参数创建ScriptEngine实例，并且将其缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ScriptEngine <span class="title">getEngine</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取脚本类型，默认是javascript</span></span><br><span class="line">    String type = url.getParameter(TYPE_KEY, DEFAULT_SCRIPT_TYPE_KEY);</span><br><span class="line">    <span class="keyword">return</span> engines.computeIfAbsent(type, t -&gt; &#123;</span><br><span class="line">        ScriptEngine scriptEngine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(type);</span><br><span class="line">        <span class="keyword">if</span> (scriptEngine == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有配置脚本路由，则报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unsupported route engine type: "</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scriptEngine;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bindings bindings = createBindings(invokers, invocation);</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行CompiledScript中的程序，并且获取Invoker数组。即脚本执行完成之后必须返回一个Invoker列表和数组。</span></span><br><span class="line">        <span class="keyword">return</span> getRoutedInvokers(function.eval(bindings));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ScriptException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"route error, rule has been ignored. rule: "</span> + rule + <span class="string">", method:"</span> +</span><br><span class="line">                invocation.getMethodName() + <span class="string">", url: "</span> + RpcContext.getContext().getUrl(), e);</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从脚本规则计算结果获取路由invokers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; getRoutedInvokers(Object obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Invoker[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList((Invoker&lt;T&gt;[]) obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream((Object[]) obj).map(item -&gt; (Invoker&lt;T&gt;) item).collect(Collectors.toList());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;Invoker&lt;T&gt;&gt;) obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为脚本引擎创建绑定参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Bindings <span class="title">createBindings</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    Bindings bindings = engine.createBindings();</span><br><span class="line">    <span class="comment">// 创建新的invokers列表</span></span><br><span class="line">    bindings.put(<span class="string">"invokers"</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(invokers));</span><br><span class="line">    bindings.put(<span class="string">"invocation"</span>, invocation);</span><br><span class="line">    bindings.put(<span class="string">"context"</span>, RpcContext.getContext());</span><br><span class="line">    <span class="keyword">return</span> bindings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-标签路由（TagRouter）"><a href="#2-3-标签路由（TagRouter）" class="headerlink" title="2.3 标签路由（TagRouter）"></a>2.3 标签路由（TagRouter）</h2><ul>
<li>参数初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"TAG_ROUTER"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_ROUTER_DEFAULT_PRIORITY = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TagRouter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULE_SUFFIX = <span class="string">".tag-router"</span>;</span><br><span class="line"><span class="comment">// 记录标签缓存Tag</span></span><br><span class="line"><span class="keyword">private</span> TagRouterRule tagRouterRule;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> String application;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TagRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">this</span>.priority = TAG_ROUTER_DEFAULT_PRIORITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析更新的路由规则</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ConfigChangedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Notification of tag rule, change type is: "</span> + event.getChangeType() + <span class="string">", raw rule is:\n "</span> +</span><br><span class="line">                event.getContent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getChangeType().equals(ConfigChangeType.DELETED)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tagRouterRule = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tagRouterRule = TagRuleParser.parse(event.getContent());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Failed to parse the raw tag router rule and it will not take effect, please check if the "</span> +</span><br><span class="line">                <span class="string">"rule matches with the template, the raw rule is:\n "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为配置中心可以更改规则，所以我们应该复制一个来使用。</span></span><br><span class="line">    <span class="keyword">final</span> TagRouterRule tagRouterRuleCopy = tagRouterRule;</span><br><span class="line">    <span class="keyword">if</span> (tagRouterRuleCopy == <span class="keyword">null</span> || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> filterUsingStaticTag(invokers, url, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; result = invokers;</span><br><span class="line">    String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) : invocation.getAttachment(TAG_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们请求具有特定标记的提供程序</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(tag)) &#123;</span><br><span class="line">        List&lt;String&gt; addresses = tagRouterRuleCopy.getTagnameToAddresses().get(tag);</span><br><span class="line">        <span class="comment">// 先按动态标记组筛选</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(addresses)) &#123;</span><br><span class="line">            <span class="comment">// 过滤掉本地已经缓存的tag，</span></span><br><span class="line">            result = filterInvoker(invokers, invoker -&gt; addressMatches(invoker.getUrl(), addresses));</span><br><span class="line">            <span class="comment">// 如果result不为空或为空但force=true，则直接返回result</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(result) || tagRouterRuleCopy.isForce()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 动态标记组没有关于请求的app的任何项，或者在经过动态标记组筛选后为空，但force=false。</span></span><br><span class="line">            <span class="comment">// 检查静态标记</span></span><br><span class="line">            result = filterInvoker(invokers, invoker -&gt; tag.equals(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有可匹配当前标记请求的标记提供程序。默认情况下，force.tag设置为false，这意味着它将调用任何不带标记的提供程序，除非显式禁止。</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(result) || isForceUseTag(invocation)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FAILOVER: 返回所有不带任何标记的Providers</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; tmp = filterInvoker(invokers, invoker -&gt; addressNotMatches(invoker.getUrl(), tagRouterRuleCopy.getAddresses()));</span><br><span class="line">            <span class="keyword">return</span> filterInvoker(tmp, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取标签tag匹配的所有服务提供者的addresse</span></span><br><span class="line">        <span class="comment">// 如下这种配置会用到：</span></span><br><span class="line">        <span class="comment">// tags:</span></span><br><span class="line">        <span class="comment">//    - name: tag1</span></span><br><span class="line">        <span class="comment">//      addresses: ["127.0.0.1:20880"]</span></span><br><span class="line">        <span class="comment">//    - name: tag2</span></span><br><span class="line">        <span class="comment">//      addresses: ["127.0.0.1:20881"]</span></span><br><span class="line">        List&lt;String&gt; addresses = tagRouterRuleCopy.getAddresses();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(addresses)) &#123;</span><br><span class="line">            result = filterInvoker(invokers, invoker -&gt; addressNotMatches(invoker.getUrl(), addresses));</span><br><span class="line">            <span class="comment">// 1.所有地址都在动态标记组中，返回空列表。</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.如果有一些地址不在任何动态标记组中，请继续使用静态标记组进行筛选</span></span><br><span class="line">        <span class="keyword">return</span> filterInvoker(result, invoker -&gt; &#123;</span><br><span class="line">            String localTag = invoker.getUrl().getParameter(TAG_KEY);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.isEmpty(localTag) || !tagRouterRuleCopy.getTagNames().contains(localTag);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果没有设置动态标记规则，请在URL中使用静态标记。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 典型的场景是使用版本2.7.x的Consumer调用使用版本2.6.x或更低版本的提供者,</span></span><br><span class="line"><span class="comment"> * 无论是否设置了动态标记规则，Consumer都应始终尊重提供程序URL中的标记。</span></span><br><span class="line"><span class="comment"> * TODO, 为了保证2.6和2.7+之间互操作性的一致性，这个方法应该与2.6.x中的TagRouter具有相同的逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; filterUsingStaticTag(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; result = invokers;</span><br><span class="line">    <span class="comment">// 动态配置的tag</span></span><br><span class="line">    String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) : invocation.getAttachment(TAG_KEY);</span><br><span class="line">    <span class="comment">// Tag请求</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(tag)) &#123;</span><br><span class="line">        <span class="comment">// 获取invoker的url中TAG_KEY标签与tag相同的invoker列表</span></span><br><span class="line">        result = filterInvoker(invokers, invoker -&gt; tag.equals(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">        <span class="comment">// 如果获取到的invoker列表且没有强制使用tag，则直接返回没有tag的invoker列表</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(result) &amp;&amp; !isForceUseTag(invocation)) &#123;</span><br><span class="line">            result = filterInvoker(invokers, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回所有未设置标签的服务提供者</span></span><br><span class="line">        result = filterInvoker(invokers, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将invokers中满足Predicate条件的invoker保留下来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; filterInvoker(List&lt;Invoker&lt;T&gt;&gt; invokers, Predicate&lt;Invoker&lt;T&gt;&gt; predicate) &#123;</span><br><span class="line">    <span class="keyword">return</span> invokers.stream()</span><br><span class="line">            .filter(predicate)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通知</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取的remote.application的value值，即应用名称</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = invokers.get(<span class="number">0</span>);</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line">    String providerApplication = url.getParameter(CommonConstants.REMOTE_APPLICATION_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(providerApplication)) &#123;</span><br><span class="line">        logger.error(<span class="string">"TagRouter must getConfig from or subscribe to a specific application, but the application in this TagRouter is not specified."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!providerApplication.equals(application)) &#123;</span><br><span class="line">            <span class="comment">// 移除当前的路由配置改变监听器</span></span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(application)) &#123;</span><br><span class="line">                ruleRepository.removeListener(application + RULE_SUFFIX, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置新的路由配置改变监听器</span></span><br><span class="line">            String key = providerApplication + RULE_SUFFIX;</span><br><span class="line">            ruleRepository.addListener(key, <span class="keyword">this</span>);</span><br><span class="line">            application = providerApplication;</span><br><span class="line">            <span class="comment">// 获取规则配置</span></span><br><span class="line">            String rawRule = ruleRepository.getRule(key, DynamicConfiguration.DEFAULT_GROUP);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(rawRule)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.process(<span class="keyword">new</span> ConfigChangedEvent(key, DynamicConfiguration.DEFAULT_GROUP, rawRule));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>






<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><blockquote>
<ol>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/router.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/source_code_guide/router.html</a></li>
</ol>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-Dubbo之SPI机制" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/18/Dubbo%E4%B9%8BSPI%E6%9C%BA%E5%88%B6/"
    >Dubbo之SPI机制</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/18/Dubbo%E4%B9%8BSPI%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-06-17T22:05:09.000Z" itemprop="datePublished">2020-06-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dubbo/">Dubbo</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-Dubbo-SPI的起源（JAVA-SPI）"><a href="#1-Dubbo-SPI的起源（JAVA-SPI）" class="headerlink" title="1 Dubbo SPI的起源（JAVA SPI）"></a>1 Dubbo SPI的起源（JAVA SPI）</h1><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。</p>
<p>因此SPI为应用程序提供了扩展功能，Dubbo正是看上了java SPI的这个特性，在java SPI的基础上扩展了更为强大的SPI功能。</p>
<p>下面我们看一下java SPI的功能</p>
<ul>
<li><p>接口定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am Man."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">implements</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am Woman."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SPI的参数配置</p>
<p>META-INF/services文件夹下创建一个文件，名称为People的全限定名org.apache.spi.People</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.spi.Man</span><br><span class="line">org.apache.spi.Woman</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务调用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSPIMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"Java SPI"</span>);</span><br><span class="line">        serviceLoader.forEach(People::say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java SPI</span><br><span class="line">Hello, I am Man.</span><br><span class="line">Hello, I am Woman.</span><br></pre></td></tr></table></figure>

<p>可以看到，通过ServiceLoader.load()方法可以加载org.apache.spi.People文件中的所有的类，并且执行里面的方法。</p>
<h1 id="2-Dubbo-SPI机制"><a href="#2-Dubbo-SPI机制" class="headerlink" title="2 Dubbo SPI机制"></a>2 Dubbo SPI机制</h1><h2 id="2-1-用法"><a href="#2-1-用法" class="headerlink" title="2.1 用法"></a>2.1 用法</h2><p>Dubbo的SPI机制是在java SPI的基础上做了进一步的扩展，是在配置文件中以Key-Value的形式，可以很方便的通过key获取需要调用类的对象。在RPC过程中，只需要在url中设置key的值，就可以实现远程指定对象的执行。而且在扩展开发时，值需要在配置文件中添加Key-Value对就可以实现功能的扩展，降低的扩展开发的耦合性。</p>
<p>Dubbod的SPI机制的使用方式如下所示（实现方式如上例所示）：</p>
<ul>
<li>配置</li>
</ul>
<p>将全限定名的文件放到META-INF/dubbo目录下，并且设置文件的内容如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Man &#x3D; org.apache.spi.Man</span><br><span class="line">Woman &#x3D; org.apache.spi.Woman</span><br></pre></td></tr></table></figure>

<ul>
<li>调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSPIMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        People man = extensionLoader.getExtension(<span class="string">"Man"</span>);</span><br><span class="line">        man.say();</span><br><span class="line">        People woman = extensionLoader.getExtension(<span class="string">"Woman"</span>);</span><br><span class="line">        woman.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java SPI</span><br><span class="line">Hello, I am Man.</span><br><span class="line">Hello, I am Woman.</span><br></pre></td></tr></table></figure>

<p>可以看到Dubbo的SPI机制封装在ExtensionLoader类中，当需要调用的时候，通过getExtensionLoader方法加载接口类，并且使用getExtension获取指定key值的对象，再通过接口调用方法即可执行对象中的方法，</p>
<h2 id="2-2-源码解析"><a href="#2-2-源码解析" class="headerlink" title="2.2 源码解析"></a>2.2 源码解析</h2><h2 id="2-2-1-Adaptive接口解析"><a href="#2-2-1-Adaptive接口解析" class="headerlink" title="2.2.1 Adaptive接口解析"></a>2.2.1 Adaptive接口解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为&#123;<span class="doctag">@link</span> extensionload&#125;注入依赖项扩展实例提供有用信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ExtensionLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;) <span class="comment">// 标记在类、接口（包括注解）、枚举和方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确定要注入的目标扩展。目标扩展名的名称由URL中传递的参数决定，参数名由此方法给定。</span></span><br><span class="line"><span class="comment">     * 如果在&#123;<span class="doctag">@link</span> URL&#125;中找不到指定的参数，则默认扩展将用于依赖注入（在其接口的&#123;<span class="doctag">@link</span> SPI&#125;中指定）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 举例：</span></span><br><span class="line"><span class="comment">     *      指定Adaptive参数：String[] &#123;"key1", "key2"&#125;</span></span><br><span class="line"><span class="comment">     *  - 在URL中查找参数“key1”，将其值用作扩展名</span></span><br><span class="line"><span class="comment">     *  - 如果在URL中找不到“key1”（或其值为空），请尝试使用“key2”作为扩展名的名称</span></span><br><span class="line"><span class="comment">     *  - 如果“key2”不存在，则使用默认扩展名</span></span><br><span class="line"><span class="comment">     *  - 否则，抛出&#123;<span class="doctag">@link</span> IllegalStateException&#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果参数名为空，则根据接口的类名生成默认的参数名，规则是：将类名与大写字符分开为多个部分，并用点“.”分隔部分，</span></span><br><span class="line"><span class="comment">     * 例如，对于&#123;<span class="doctag">@code</span> org.apache.dubbo.xxx.YyyInvokerWrapper&#125;，生成的名称是String[] &#123;"yyy.invoker.wrapper"</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> parameter names in URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-2-Active接口解析"><a href="#2-2-2-Active接口解析" class="headerlink" title="2.2.2 Active接口解析"></a>2.2.2 Active接口解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Activate. This annotation is useful for automatically activate certain extensions with the given criteria,</span></span><br><span class="line"><span class="comment"> * for examples: &lt;code&gt;<span class="doctag">@Activate</span>&lt;/code&gt; can be used to load certain &lt;code&gt;Filter&lt;/code&gt; extension when there are</span></span><br><span class="line"><span class="comment"> * multiple implementations.</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> Activate#group()&#125; specifies group criteria. Framework SPI defines the valid group values.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> Activate#value()&#125; specifies parameter key in &#123;<span class="doctag">@link</span> URL&#125; criteria.</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> * SPI provider can call &#123;<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)&#125; to find out all activated</span></span><br><span class="line"><span class="comment"> * extensions with the given criteria.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SPI</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ExtensionLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Activate the current extension when one of the groups matches. The group passed into</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ExtensionLoader#getActivateExtension(URL, String, String)&#125; will be used for matching.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> group names to match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Activate the current extension when the specified keys appear in the URL's parameters.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * For example, given &lt;code&gt;<span class="doctag">@Activate</span>("cache, validation")&lt;/code&gt;, the current extension will be return only when</span></span><br><span class="line"><span class="comment">     * there's either &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;validation&lt;/code&gt; key appeared in the URL's parameters.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> URL parameter keys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ExtensionLoader#getActivateExtension(URL, String, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Relative ordering info, optional</span></span><br><span class="line"><span class="comment">     * Deprecated since 2.7.0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put before the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Relative ordering info, optional</span></span><br><span class="line"><span class="comment">     * Deprecated since 2.7.0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> extension list which should be put after the current one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Absolute ordering info, optional</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> absolute ordering info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-3-解析过程源码分析"><a href="#2-2-3-解析过程源码分析" class="headerlink" title="2.2.3 解析过程源码分析"></a>2.2.3 解析过程源码分析</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><blockquote>
<ol>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html</a></li>
</ol>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-IDEA插件开发" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/18/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"
    >IDEA插件开发</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/18/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" class="article-date">
  <time datetime="2020-06-17T22:04:37.000Z" itemprop="datePublished">2020-06-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-项目开发流程"><a href="#1-项目开发流程" class="headerlink" title="1 项目开发流程"></a>1 项目开发流程</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--插件ID,需要全局唯一--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>com.your.company.unique.plugin.id<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--插件名称--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>FirstPlugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">"3221602630@qq.com"</span> <span class="attr">url</span>=<span class="string">"http://daniel-brute.github.io"</span>&gt;</span>nucc<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--插件功能描述--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      enter sho1rt description for your plugin here.&lt;br&gt;</span><br><span class="line">      &lt;em&gt;most HTM1L tags may be used&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--变更日志--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">change-notes</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      add change 1notes here.&lt;br&gt;</span><br><span class="line">      &lt;em&gt;most HTM1WL tags may be used&lt;/em&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">change-notes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--插件支持idea的版本--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">idea-version</span> <span class="attr">since-build</span>=<span class="string">"173.0"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--其他相关的依赖--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- please see https://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html</span></span><br><span class="line"><span class="comment">       on how to target different products --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.platform<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--扩展内容--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">"com.intellij"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--菜单动作--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">id</span>=<span class="string">"FirstPluginActionID"</span> <span class="attr">class</span>=<span class="string">"com.zhangyuhu.demo.FirstPluginAction"</span> <span class="attr">text</span>=<span class="string">"测试"</span> <span class="attr">description</span>=<span class="string">"测试描述"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">add-to-group</span> <span class="attr">group-id</span>=<span class="string">"ToolsMenu"</span> <span class="attr">anchor</span>=<span class="string">"first"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keyboard-shortcut</span> <span class="attr">keymap</span>=<span class="string">"$default"</span> <span class="attr">first-keystroke</span>=<span class="string">"ctrl I"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NotificationGroup notificationGroup = <span class="keyword">new</span> NotificationGroup(<span class="string">"pluginid"</span>, NotificationDisplayType.BALLOON,<span class="keyword">true</span>);</span><br><span class="line">Notification notification = notificationGroup.createNotification(<span class="string">"点击测试"</span>, MessageType.WARNING);</span><br><span class="line">Notifications.Bus.notify(notification);</span><br></pre></td></tr></table></figure>
<h1 id="3-Component"><a href="#3-Component" class="headerlink" title="3 Component"></a>3 Component</h1><h1 id="4-Extensions-and-Extension-Points"><a href="#4-Extensions-and-Extension-Points" class="headerlink" title="4 Extensions and Extension Points"></a>4 Extensions and Extension Points</h1><h1 id="5-Service"><a href="#5-Service" class="headerlink" title="5 Service"></a>5 Service</h1><h1 id="6-持久化状态"><a href="#6-持久化状态" class="headerlink" title="6 持久化状态"></a>6 持久化状态</h1><h1 id="7-插件依赖"><a href="#7-插件依赖" class="headerlink" title="7  插件依赖"></a>7  插件依赖</h1>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-Dubbo之服务自省" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/14/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E8%87%AA%E7%9C%81/"
    >Dubbo之服务自省</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/14/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E8%87%AA%E7%9C%81/" class="article-date">
  <time datetime="2020-06-14T15:19:37.000Z" itemprop="datePublished">2020-06-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dubbo/">Dubbo</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>dubbo面临的挑战：<br>1、如何解决或者缓解注册中心压力过载：内存、网络和通知<br>2、如何支持以应用为力度的服务注册与发现：支持SpringCloud、Kubernates和兼容Dubbo传统服务注册与发现。<br>3、如何精简dubbo URL元数据：将不变的数据放到元数据中心</p>
<p>起源：<br>JavaBeans自省：At runtime and in the builder environment we need to be able to figure out which properties, event, and methods a java Bean supports. we call this proccess instrospection.</p>
<p>定义：Dubbo应用在运行时处理和分析Dubbo服务源信息的过程。如当前应用暴露的Dubbo服务以及各自通讯协议等。期间会伴随着时间的广播和处理，如服务暴露事件。</p>
<p>服务自省架构定义：</p>
<p>Service：SOA或者微服务中的“服务”，或者称之为“应用”，具有全局唯一的名称。</p>
<p>ServiceName：服务名称，或者应用名称。</p>
<p>Service Instance：服务实例，或者称应用实例（Application Instance），表示单个Dubbo应用进程。</p>
<p>Registry：注册中心</p>
<p>Dubbo服务：又称之为“Dubbo业务服务”，包括Java接口、通讯协议、版本（version）和分组（group）等元信息。</p>
<p>Dubbo服务ID：唯一鉴定Dubbo服务的元数据，用于Dubbo服务暴漏（发布）和订阅。</p>
<p>Provider：Dubbo服务提供方</p>
<p>Consumer：Dubbo服务消费方</p>
<p>Dubbo服务暴露：也称之为Dubbo服务发布，或者英文中的“export”，“exported”</p>
<p>Dubbo应用服务：也称之为Dubbo业务服务，或业务Dubbo服务</p>
<p>使用场景：</p>
<ul>
<li>超大规模Dubbo服务治理场景</li>
</ul>
<p>如果Dubbo集群规模超过一千以上，或者集群扩缩容已无法自如地执行，如zk管理数万Dubbo服务，服务自省可以极大化减轻注册中心地压力，尤其在内存足迹、网络传输以及变更通知上体现。</p>
<ul>
<li>微服务架构和元原生应用</li>
</ul>
<p>如果想要Dubbo应用更好地微服务化，或者更接近于云原生应用，那么服务自省是一种不错的选择，它能够提供以应用为粒度的服务注册与发现模型，全面地支持最流行地Spring Cloud和Kubernates注册中心，并且能够与Spring Cloud或Spring Boot应用交互。</p>
<ul>
<li>Dubbo元数据架构的基石</li>
</ul>
<p>Dubbo元数据架构是围绕Dubbo DevOps而引入的，包括Dubbo配置元数据（如：配置属性、路由规则等）和机构元数据（如Java注解、接口和文档等）。服务自省作为Dubbo元数据的基础设施，不仅支持所有的存储和平滑升级，而且不会对注册中心和元数据中心产生额外的负担。</p>
<ul>
<li>传统架构</li>
</ul>
<p>是一款面向接口的代理的高性能RPC框架，提供服务注册于发现的特性，其基础架构如下图所示：<br><img src alt></p>
<h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h1><h1 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3 使用方式"></a>3 使用方式</h1><h1 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4 源码分析"></a>4 源码分析</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><blockquote>
<p>1.</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
    <article id="post-Spring循环依赖解决方案" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/14/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"
    >Spring依赖循环解决方案</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/14/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time datetime="2020-06-13T23:47:34.000Z" itemprop="datePublished">2020-06-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-Spring不带参数对象获取过程"><a href="#1-Spring不带参数对象获取过程" class="headerlink" title="1 Spring不带参数对象获取过程"></a>1 Spring不带参数对象获取过程</h1><p>解析源码的版本：spring-context-2.5.6.SEC03</p>
<p>在Spring的bean装配方法是在AbstractBeanFactory类的doGetBean方法中实现的，为了防止循环依赖的产生，Spring使用了两个中间存储对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 获取早期创建的单例对象 bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map earlySingletonObjects = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前正准备常见的bean单例对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set singletonsCurrentlyInCreation = Collections.synchronizedSet(<span class="keyword">new</span> HashSet());</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 存储已经创建bean的名称 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set alreadyCreated = Collections.synchronizedSet(<span class="keyword">new</span> HashSet());</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 存储正准备创建beans的名称：循环依赖的判定的依据 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal prototypesCurrentlyInCreation = <span class="keyword">new</span> NamedThreadLocal(<span class="string">"Prototype beans currently in creation"</span>);</span><br></pre></td></tr></table></figure>

<p>根据上面的AbstractBeanFacotry内部提供的为了解决循环依赖和效率问题提供的四个存储器可知，在解决循环依赖时会使用中间变量存储待实例化的bean，因此通过分析下面三个方法可以清楚地明白SpringFramework如何解决循环依赖问题。</p>
<p>在创建bean时，bean主要分三种singleton、Prototype和其他。SpringFramework在创建bean时分这三种类型分别创建bean。总的创建实例原则是先查缓存，如果缓存没有再使用beanFactory创建bean实例。这样做的好处是可以提高bean创建的效率。</p>
<p>在获取实例的时候，首先是使用getSingleton()方法从singletonObjects中获取当前缓存中的bean，方法如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个通过bean名称可以获取的已经注册的单例bean对象</span></span><br><span class="line"><span class="comment"> * 检测当前的单例对象是否已经存在，还允许早期引用当前创建的单例（解决循环引用的问题）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName 需要查找bean对象的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference 是否应创建早期的引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 已经注册的bean对象, 或者在不存在时返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取当前缓存中的bean对象</span></span><br><span class="line">	Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">	<span class="comment">// 如果对象不存在，且allowEarlyReference为true时，创建bean对象</span></span><br><span class="line">	<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 同步锁，防止多线程创建时发生碰撞</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="comment">// 在earlySingletonObjects中获取bean实例</span></span><br><span class="line">			singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="comment">// 获取创建bean的ObjectFactory，用以创建bean实例</span></span><br><span class="line">				ObjectFactory singletonFactory = (ObjectFactory) <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 创建bean实例</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					<span class="comment">// 将bean的名称和实例存储在缓存earlySingletonObjects中</span></span><br><span class="line">					<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					<span class="comment">// 移除创建bean的ObjectFactory</span></span><br><span class="line">					<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在doGetBean()方法的第一步就是通过此方法获取bean对象，而且allowEarlyReference标签在默认情况下是true，即在获取的对象scope为单例（默认为单例）时会在此方法中获取bean的对象。</p>
<p>由上面的代码可以看出，单例的bean获取首先在singletonObjects的缓存中获取，再在earlySingletonObjects中获取，最后如果前面两个缓存中都不存在将会通过ObjectFactory创建新的实例并放在earlySingletonObjects中。由代码可见每次创建bean的对象是ObjectFactory，并且在创建完bean对象之后销毁ObjectFactory。</p>
<p>在代码中存在一个问题，在获取bean实例时，虽然在singletonObjects中获取对象，但是创建完对象之后，并没有将实例存放在singletonObjects中，那么singletonObjects中的对象是什么时候放进去的呢？</p>
<p>答案是在手动注册bean对象的时候会将调用DefaultSingletonBeanRegistry的方法将对象存放在singletonObjects中，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">	Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">		Object oldObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (oldObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not register object ["</span> + singletonObject +</span><br><span class="line">					<span class="string">"] under bean name '"</span> + beanName + <span class="string">"': there is already object ["</span> + oldObject + <span class="string">"] bound"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		addSingleton(beanName, singletonObject);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将bean对象添加到单例缓存中，被單例的eager类型的注册</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName bean名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> singletonObject bean实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">		<span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line">		<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">		<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">		<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提供的这些方法，是提供给开发者手动注册bean对象到singletonObjects对象中，比如在AbstractApplicationContext中的事件广播和messageSource就是在容器初始化的时候使用registerSingleton注册bean对象。</p>
<p>在上面的代码中将创建在singletonObject中，是不是bean的实例就创建完成了呢？</p>
<p>答案当然不是，因为bean包含两种，一种是单纯的bean，另一种是beanFactory。对于单纯的bean自然直接就返回了，而对于FactoryBean则不是，因为它的内部还包含尚未实例化的bean。循环引用恰恰就是出现在FactoryBean当中。下面我们来看看FactroyBean的实例化过程。</p>
<p>FactoryBean的获取过程是在FactoryBeanRegistrySupport类中实现的，在FactoryBeanRegistrySupport中有下面的缓存对象，专门来存储FactoryBean对象。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map factoryBeanObjectCache = CollectionFactory.createConcurrentMapIfPossible(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>在创建FactoryBean的时候，同样现在factoryBeanObjectCache中获取，如果不存在，则使用getObjectFromFactoryBean()方法获取FactoryBean实例，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain an object to expose from the given FactoryBean, if available</span></span><br><span class="line"><span class="comment"> * in cached form. Quick check for minimal synchronization.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object obtained from the FactoryBean,</span></span><br><span class="line"><span class="comment"> * or &lt;code&gt;null&lt;/code&gt; if not available</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getCachedObjectForFactoryBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">	Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">	<span class="keyword">return</span> (object != NULL_OBJECT ? object : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain an object to expose from the given FactoryBean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory the FactoryBean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shouldPostProcess whether the bean is subject for post-processing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object obtained from the FactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if FactoryBean object creation failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean#getObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">			Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">				object = doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">				<span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, (object != <span class="keyword">null</span> ? object : NULL_OBJECT));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (object != NULL_OBJECT ? object : <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的第二个方法中可以看到，getObjectFromFactoryBean方法调用doGetObjectFromFactoryBean创建FactoryBean，创建成功之后，就将创建完成的FactoryBean存放在缓存factoryBeanObjectCache中。具体创建过程如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain an object to expose from the given FactoryBean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory the FactoryBean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shouldPostProcess whether the bean is subject for post-processing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object obtained from the FactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if FactoryBean object creation failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean#getObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> FactoryBean factory, <span class="keyword">final</span> String beanName, <span class="keyword">final</span> <span class="keyword">boolean</span> shouldPostProcess)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	AccessControlContext acc = AccessController.getContext();</span><br><span class="line">	<span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Object object;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = factory.getObject();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"FactoryBean threw exception on object creation"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Do not accept a null value for a FactoryBean that's not fully</span></span><br><span class="line">			<span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">			<span class="keyword">if</span> (object == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(</span><br><span class="line">						beanName, <span class="string">"FactoryBean which is currently in creation returned null from getObject"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of the FactoryBean's object failed"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> object;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, acc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面可以看到创建FactoryBean时就一条语句factory.getObject()，那么factory.getObject()干了什么呢？</p>
<p>这个方法的实现可以自定义类实现，只需要实现FactoryBean方法即可，可以自已实现需要定义的对象实例返回。既可以new一个对象或者使用getBean()方法返回。使用getBean()方法相当于递归调用doGetBean()方法创建非FactoryBean的bean对象。</p>
<h1 id="2-Spring带参数的对象获取过程"><a href="#2-Spring带参数的对象获取过程" class="headerlink" title="2 Spring带参数的对象获取过程"></a>2 Spring带参数的对象获取过程</h1><p>在创建一个对象的前戏不仅包含了第一章的内容还有下面这段代码，之所以分成两部分，是针对循环依赖的处理的，第一章的内容可以只做简单的对象创建，而不用处理循环依赖。同时对于BeanFactrory的内部对象（如果含有参数）的创建同样会使用下面这段代码创建实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环依赖检查</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取BeanFactory，如果BeanFactory不为空直接获取bean的实例返回</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">	<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">	String nameToLookup = originalBeanName(name);</span><br><span class="line">	<span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">		<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">		<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前的bean标记为已创建</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">	markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并beanDefinition</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 检查合并之后的beanDefinition是否合法，抽象方法和Prototype类型的对象参数不为空时抛出异常</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取depends-on的属性值，如果depends-on的值存在，则添加进入dependentBeanMap缓存中</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dependsOn.length; i++) &#123;</span><br><span class="line">		String dependsOnBean = dependsOn[i];</span><br><span class="line">		getBean(dependsOnBean);</span><br><span class="line">		registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建singleton对象实例的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">	sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 创建对象实例</span></span><br><span class="line">				<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">				<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">				<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">				destroySingleton(beanName);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，对于单例模式的对象只要是通过createBean()对象创建bean实例后，校验bean的合法性之后直接就返回了。</p>
<p>创建prototype对象实例的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">	<span class="comment">// 存储prototype类型的对象</span></span><br><span class="line">	Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 将需要创建bean存储到prototypesCurrentlyInCreation中</span></span><br><span class="line">		beforePrototypeCreation(beanName);</span><br><span class="line">		<span class="comment">// 创建对象实例</span></span><br><span class="line">		prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 默认实现将prototype标记为不再处于创建中</span></span><br><span class="line">		afterPrototypeCreation(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在需要重点说明的是afterPrototypeCreation方法。因为这个方法涉及到循环依赖问题。需要结合下一章的说明了解循环依赖问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prototype对象创建之后的回调方法</span></span><br><span class="line"><span class="comment"> * 标识当前prototype类型的对象不再创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName 已将创建的prototype类型的bean名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isPrototypeCurrentlyInCreation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterPrototypeCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">	Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">	<span class="keyword">if</span> (curVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		<span class="keyword">this</span>.prototypesCurrentlyInCreation.set(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (curVal <span class="keyword">instanceof</span> Set) &#123;</span><br><span class="line">		Set beanNameSet = (Set) curVal;</span><br><span class="line">		beanNameSet.remove(beanName);</span><br><span class="line">		<span class="keyword">if</span> (beanNameSet.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.prototypesCurrentlyInCreation.set(<span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建其它类型对象实例的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = (Scope) <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">			<span class="comment">// 将需要创建bean存储到prototypesCurrentlyInCreation中</span></span><br><span class="line">			beforePrototypeCreation(beanName);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 创建对象实例</span></span><br><span class="line">				<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// 默认实现将prototype标记为不再处于创建中</span></span><br><span class="line">				afterPrototypeCreation(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">		<span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; "</span> +</span><br><span class="line">		<span class="string">"consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">		ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其他类型的处理和prototype类型的bean实例化是一样的，只是创建对象的方法不一样。其他类型使用Object get(String name, ObjectFactory objectFactory)方法获取的。</p>
<h1 id="3-循环依赖"><a href="#3-循环依赖" class="headerlink" title="3 循环依赖"></a>3 循环依赖</h1><p>要程序运行到循环依赖判断，只有args!=null的情况。咋一看getSingleton()方法中的(ObjectFactory) this.singletonFactories.get(beanName)语句会返回null也可运行到此步骤，但是我们看一下ObjectFactroty.getObject()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance (possibly shared or independent)</span></span><br><span class="line"><span class="comment"> * of the object managed by this factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean (should never be &lt;code&gt;null&lt;/code&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到getObject()方法不可能返回null，因此只能寄希望于args!=null的情况。可以看出来存在循环依赖的对象，其必然会有参数，且这个参数直接或者间接的依赖于自己。循环依赖的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回特定的prototype类型的bean是否是在正在创建中（在当前线程中国）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName bean的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isPrototypeCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">	Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">	<span class="keyword">return</span> (curVal != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">			(curVal.equals(beanName) || (curVal <span class="keyword">instanceof</span> Set &amp;&amp; ((Set) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看出curVal的Set集合集合中含有此bean时才会产生循环依赖。有第二章的的说明可知，singleton类型的对象创建时是不可能产生循环依赖其，他情况都可以产生循环依赖。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>依赖循环判断的依赖重要的缓存对象prototypesCurrentlyInCreation，当bean实例创建之前会把bean的名称存储在这个对象中，创建成功之后会将bean名称从这个对象中删除。在创建新对象的过程中如果isPrototypeCurrentlyInCreation()方法中判断新创建的bean名称已经存在prototypesCurrentlyInCreation中，则会报循环依赖异常。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>


    </footer>

  </div>

  

  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <!-- <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> 张玉虎
      </li>
    </ul> -->
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="张玉虎"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      <!--  -->
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['convertion over configuration', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>





<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>


<!-- 复制 -->

  
<link rel="stylesheet" href="/css/clipboard.css">

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




    
  </div>
</body>

</html>